// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

func (a *Anime) Episodes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*EpisodeOrder,
) (*EpisodeConnection, error) {
	opts := []EpisodePaginateOption{
		WithEpisodeOrder(orderBy),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := a.Edges.totalCount[0][alias]
	if nodes, err := a.NamedEpisodes(alias); err == nil || hasTotalCount {
		pager, err := newEpisodePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &EpisodeConnection{Edges: []*EpisodeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return a.QueryEpisodes().Paginate(ctx, after, first, before, last, opts...)
}

func (e *Episode) Item(ctx context.Context) (*Item, error) {
	result, err := e.Edges.ItemOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryItem().Only(ctx)
	}
	return result, err
}

func (e *Episode) Anime(ctx context.Context) (*Anime, error) {
	result, err := e.Edges.AnimeOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryAnime().Only(ctx)
	}
	return result, err
}

func (e *Episode) ReleaseGroup(ctx context.Context) (*ReleaseGroup, error) {
	result, err := e.Edges.ReleaseGroupOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryReleaseGroup().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (i *Item) Episode(ctx context.Context) (*Episode, error) {
	result, err := i.Edges.EpisodeOrErr()
	if IsNotLoaded(err) {
		result, err = i.QueryEpisode().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (rg *ReleaseGroup) Episodes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*EpisodeOrder,
) (*EpisodeConnection, error) {
	opts := []EpisodePaginateOption{
		WithEpisodeOrder(orderBy),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := rg.Edges.totalCount[0][alias]
	if nodes, err := rg.NamedEpisodes(alias); err == nil || hasTotalCount {
		pager, err := newEpisodePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &EpisodeConnection{Edges: []*EpisodeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return rg.QueryEpisodes().Paginate(ctx, after, first, before, last, opts...)
}
