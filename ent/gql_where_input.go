// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/eiri/konyanko/ent/anime"
	"github.com/eiri/konyanko/ent/episode"
	"github.com/eiri/konyanko/ent/item"
	"github.com/eiri/konyanko/ent/predicate"
	"github.com/eiri/konyanko/ent/releasegroup"
)

// AnimeWhereInput represents a where input for filtering Anime queries.
type AnimeWhereInput struct {
	Predicates []predicate.Anime  `json:"-"`
	Not        *AnimeWhereInput   `json:"not,omitempty"`
	Or         []*AnimeWhereInput `json:"or,omitempty"`
	And        []*AnimeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "episodes" edge predicates.
	HasEpisodes     *bool                `json:"hasEpisodes,omitempty"`
	HasEpisodesWith []*EpisodeWhereInput `json:"hasEpisodesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AnimeWhereInput) AddPredicates(predicates ...predicate.Anime) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AnimeWhereInput filter on the AnimeQuery builder.
func (i *AnimeWhereInput) Filter(q *AnimeQuery) (*AnimeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAnimeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAnimeWhereInput is returned in case the AnimeWhereInput is empty.
var ErrEmptyAnimeWhereInput = errors.New("ent: empty predicate AnimeWhereInput")

// P returns a predicate for filtering animes.
// An error is returned if the input is empty or invalid.
func (i *AnimeWhereInput) P() (predicate.Anime, error) {
	var predicates []predicate.Anime
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, anime.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Anime, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, anime.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Anime, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, anime.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, anime.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, anime.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, anime.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, anime.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, anime.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, anime.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, anime.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, anime.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, anime.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, anime.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, anime.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, anime.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, anime.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, anime.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, anime.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, anime.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, anime.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, anime.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, anime.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, anime.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, anime.TitleContainsFold(*i.TitleContainsFold))
	}

	if i.HasEpisodes != nil {
		p := anime.HasEpisodes()
		if !*i.HasEpisodes {
			p = anime.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpisodesWith) > 0 {
		with := make([]predicate.Episode, 0, len(i.HasEpisodesWith))
		for _, w := range i.HasEpisodesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpisodesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, anime.HasEpisodesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAnimeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return anime.And(predicates...), nil
	}
}

// EpisodeWhereInput represents a where input for filtering Episode queries.
type EpisodeWhereInput struct {
	Predicates []predicate.Episode  `json:"-"`
	Not        *EpisodeWhereInput   `json:"not,omitempty"`
	Or         []*EpisodeWhereInput `json:"or,omitempty"`
	And        []*EpisodeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "episode_number" field predicates.
	EpisodeNumber      *int  `json:"episodeNumber,omitempty"`
	EpisodeNumberNEQ   *int  `json:"episodeNumberNEQ,omitempty"`
	EpisodeNumberIn    []int `json:"episodeNumberIn,omitempty"`
	EpisodeNumberNotIn []int `json:"episodeNumberNotIn,omitempty"`
	EpisodeNumberGT    *int  `json:"episodeNumberGT,omitempty"`
	EpisodeNumberGTE   *int  `json:"episodeNumberGTE,omitempty"`
	EpisodeNumberLT    *int  `json:"episodeNumberLT,omitempty"`
	EpisodeNumberLTE   *int  `json:"episodeNumberLTE,omitempty"`

	// "anime_season" field predicates.
	AnimeSeason      *int  `json:"animeSeason,omitempty"`
	AnimeSeasonNEQ   *int  `json:"animeSeasonNEQ,omitempty"`
	AnimeSeasonIn    []int `json:"animeSeasonIn,omitempty"`
	AnimeSeasonNotIn []int `json:"animeSeasonNotIn,omitempty"`
	AnimeSeasonGT    *int  `json:"animeSeasonGT,omitempty"`
	AnimeSeasonGTE   *int  `json:"animeSeasonGTE,omitempty"`
	AnimeSeasonLT    *int  `json:"animeSeasonLT,omitempty"`
	AnimeSeasonLTE   *int  `json:"animeSeasonLTE,omitempty"`

	// "resolution" field predicates.
	Resolution             *string  `json:"resolution,omitempty"`
	ResolutionNEQ          *string  `json:"resolutionNEQ,omitempty"`
	ResolutionIn           []string `json:"resolutionIn,omitempty"`
	ResolutionNotIn        []string `json:"resolutionNotIn,omitempty"`
	ResolutionGT           *string  `json:"resolutionGT,omitempty"`
	ResolutionGTE          *string  `json:"resolutionGTE,omitempty"`
	ResolutionLT           *string  `json:"resolutionLT,omitempty"`
	ResolutionLTE          *string  `json:"resolutionLTE,omitempty"`
	ResolutionContains     *string  `json:"resolutionContains,omitempty"`
	ResolutionHasPrefix    *string  `json:"resolutionHasPrefix,omitempty"`
	ResolutionHasSuffix    *string  `json:"resolutionHasSuffix,omitempty"`
	ResolutionIsNil        bool     `json:"resolutionIsNil,omitempty"`
	ResolutionNotNil       bool     `json:"resolutionNotNil,omitempty"`
	ResolutionEqualFold    *string  `json:"resolutionEqualFold,omitempty"`
	ResolutionContainsFold *string  `json:"resolutionContainsFold,omitempty"`

	// "video_codec" field predicates.
	VideoCodec             *string  `json:"videoCodec,omitempty"`
	VideoCodecNEQ          *string  `json:"videoCodecNEQ,omitempty"`
	VideoCodecIn           []string `json:"videoCodecIn,omitempty"`
	VideoCodecNotIn        []string `json:"videoCodecNotIn,omitempty"`
	VideoCodecGT           *string  `json:"videoCodecGT,omitempty"`
	VideoCodecGTE          *string  `json:"videoCodecGTE,omitempty"`
	VideoCodecLT           *string  `json:"videoCodecLT,omitempty"`
	VideoCodecLTE          *string  `json:"videoCodecLTE,omitempty"`
	VideoCodecContains     *string  `json:"videoCodecContains,omitempty"`
	VideoCodecHasPrefix    *string  `json:"videoCodecHasPrefix,omitempty"`
	VideoCodecHasSuffix    *string  `json:"videoCodecHasSuffix,omitempty"`
	VideoCodecIsNil        bool     `json:"videoCodecIsNil,omitempty"`
	VideoCodecNotNil       bool     `json:"videoCodecNotNil,omitempty"`
	VideoCodecEqualFold    *string  `json:"videoCodecEqualFold,omitempty"`
	VideoCodecContainsFold *string  `json:"videoCodecContainsFold,omitempty"`

	// "audio_codec" field predicates.
	AudioCodec             *string  `json:"audioCodec,omitempty"`
	AudioCodecNEQ          *string  `json:"audioCodecNEQ,omitempty"`
	AudioCodecIn           []string `json:"audioCodecIn,omitempty"`
	AudioCodecNotIn        []string `json:"audioCodecNotIn,omitempty"`
	AudioCodecGT           *string  `json:"audioCodecGT,omitempty"`
	AudioCodecGTE          *string  `json:"audioCodecGTE,omitempty"`
	AudioCodecLT           *string  `json:"audioCodecLT,omitempty"`
	AudioCodecLTE          *string  `json:"audioCodecLTE,omitempty"`
	AudioCodecContains     *string  `json:"audioCodecContains,omitempty"`
	AudioCodecHasPrefix    *string  `json:"audioCodecHasPrefix,omitempty"`
	AudioCodecHasSuffix    *string  `json:"audioCodecHasSuffix,omitempty"`
	AudioCodecIsNil        bool     `json:"audioCodecIsNil,omitempty"`
	AudioCodecNotNil       bool     `json:"audioCodecNotNil,omitempty"`
	AudioCodecEqualFold    *string  `json:"audioCodecEqualFold,omitempty"`
	AudioCodecContainsFold *string  `json:"audioCodecContainsFold,omitempty"`

	// "item" edge predicates.
	HasItem     *bool             `json:"hasItem,omitempty"`
	HasItemWith []*ItemWhereInput `json:"hasItemWith,omitempty"`

	// "anime" edge predicates.
	HasAnime     *bool              `json:"hasAnime,omitempty"`
	HasAnimeWith []*AnimeWhereInput `json:"hasAnimeWith,omitempty"`

	// "release_group" edge predicates.
	HasReleaseGroup     *bool                     `json:"hasReleaseGroup,omitempty"`
	HasReleaseGroupWith []*ReleaseGroupWhereInput `json:"hasReleaseGroupWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EpisodeWhereInput) AddPredicates(predicates ...predicate.Episode) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EpisodeWhereInput filter on the EpisodeQuery builder.
func (i *EpisodeWhereInput) Filter(q *EpisodeQuery) (*EpisodeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEpisodeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEpisodeWhereInput is returned in case the EpisodeWhereInput is empty.
var ErrEmptyEpisodeWhereInput = errors.New("ent: empty predicate EpisodeWhereInput")

// P returns a predicate for filtering episodes.
// An error is returned if the input is empty or invalid.
func (i *EpisodeWhereInput) P() (predicate.Episode, error) {
	var predicates []predicate.Episode
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, episode.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Episode, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, episode.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Episode, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, episode.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, episode.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, episode.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, episode.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, episode.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, episode.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, episode.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, episode.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, episode.IDLTE(*i.IDLTE))
	}
	if i.EpisodeNumber != nil {
		predicates = append(predicates, episode.EpisodeNumberEQ(*i.EpisodeNumber))
	}
	if i.EpisodeNumberNEQ != nil {
		predicates = append(predicates, episode.EpisodeNumberNEQ(*i.EpisodeNumberNEQ))
	}
	if len(i.EpisodeNumberIn) > 0 {
		predicates = append(predicates, episode.EpisodeNumberIn(i.EpisodeNumberIn...))
	}
	if len(i.EpisodeNumberNotIn) > 0 {
		predicates = append(predicates, episode.EpisodeNumberNotIn(i.EpisodeNumberNotIn...))
	}
	if i.EpisodeNumberGT != nil {
		predicates = append(predicates, episode.EpisodeNumberGT(*i.EpisodeNumberGT))
	}
	if i.EpisodeNumberGTE != nil {
		predicates = append(predicates, episode.EpisodeNumberGTE(*i.EpisodeNumberGTE))
	}
	if i.EpisodeNumberLT != nil {
		predicates = append(predicates, episode.EpisodeNumberLT(*i.EpisodeNumberLT))
	}
	if i.EpisodeNumberLTE != nil {
		predicates = append(predicates, episode.EpisodeNumberLTE(*i.EpisodeNumberLTE))
	}
	if i.AnimeSeason != nil {
		predicates = append(predicates, episode.AnimeSeasonEQ(*i.AnimeSeason))
	}
	if i.AnimeSeasonNEQ != nil {
		predicates = append(predicates, episode.AnimeSeasonNEQ(*i.AnimeSeasonNEQ))
	}
	if len(i.AnimeSeasonIn) > 0 {
		predicates = append(predicates, episode.AnimeSeasonIn(i.AnimeSeasonIn...))
	}
	if len(i.AnimeSeasonNotIn) > 0 {
		predicates = append(predicates, episode.AnimeSeasonNotIn(i.AnimeSeasonNotIn...))
	}
	if i.AnimeSeasonGT != nil {
		predicates = append(predicates, episode.AnimeSeasonGT(*i.AnimeSeasonGT))
	}
	if i.AnimeSeasonGTE != nil {
		predicates = append(predicates, episode.AnimeSeasonGTE(*i.AnimeSeasonGTE))
	}
	if i.AnimeSeasonLT != nil {
		predicates = append(predicates, episode.AnimeSeasonLT(*i.AnimeSeasonLT))
	}
	if i.AnimeSeasonLTE != nil {
		predicates = append(predicates, episode.AnimeSeasonLTE(*i.AnimeSeasonLTE))
	}
	if i.Resolution != nil {
		predicates = append(predicates, episode.ResolutionEQ(*i.Resolution))
	}
	if i.ResolutionNEQ != nil {
		predicates = append(predicates, episode.ResolutionNEQ(*i.ResolutionNEQ))
	}
	if len(i.ResolutionIn) > 0 {
		predicates = append(predicates, episode.ResolutionIn(i.ResolutionIn...))
	}
	if len(i.ResolutionNotIn) > 0 {
		predicates = append(predicates, episode.ResolutionNotIn(i.ResolutionNotIn...))
	}
	if i.ResolutionGT != nil {
		predicates = append(predicates, episode.ResolutionGT(*i.ResolutionGT))
	}
	if i.ResolutionGTE != nil {
		predicates = append(predicates, episode.ResolutionGTE(*i.ResolutionGTE))
	}
	if i.ResolutionLT != nil {
		predicates = append(predicates, episode.ResolutionLT(*i.ResolutionLT))
	}
	if i.ResolutionLTE != nil {
		predicates = append(predicates, episode.ResolutionLTE(*i.ResolutionLTE))
	}
	if i.ResolutionContains != nil {
		predicates = append(predicates, episode.ResolutionContains(*i.ResolutionContains))
	}
	if i.ResolutionHasPrefix != nil {
		predicates = append(predicates, episode.ResolutionHasPrefix(*i.ResolutionHasPrefix))
	}
	if i.ResolutionHasSuffix != nil {
		predicates = append(predicates, episode.ResolutionHasSuffix(*i.ResolutionHasSuffix))
	}
	if i.ResolutionIsNil {
		predicates = append(predicates, episode.ResolutionIsNil())
	}
	if i.ResolutionNotNil {
		predicates = append(predicates, episode.ResolutionNotNil())
	}
	if i.ResolutionEqualFold != nil {
		predicates = append(predicates, episode.ResolutionEqualFold(*i.ResolutionEqualFold))
	}
	if i.ResolutionContainsFold != nil {
		predicates = append(predicates, episode.ResolutionContainsFold(*i.ResolutionContainsFold))
	}
	if i.VideoCodec != nil {
		predicates = append(predicates, episode.VideoCodecEQ(*i.VideoCodec))
	}
	if i.VideoCodecNEQ != nil {
		predicates = append(predicates, episode.VideoCodecNEQ(*i.VideoCodecNEQ))
	}
	if len(i.VideoCodecIn) > 0 {
		predicates = append(predicates, episode.VideoCodecIn(i.VideoCodecIn...))
	}
	if len(i.VideoCodecNotIn) > 0 {
		predicates = append(predicates, episode.VideoCodecNotIn(i.VideoCodecNotIn...))
	}
	if i.VideoCodecGT != nil {
		predicates = append(predicates, episode.VideoCodecGT(*i.VideoCodecGT))
	}
	if i.VideoCodecGTE != nil {
		predicates = append(predicates, episode.VideoCodecGTE(*i.VideoCodecGTE))
	}
	if i.VideoCodecLT != nil {
		predicates = append(predicates, episode.VideoCodecLT(*i.VideoCodecLT))
	}
	if i.VideoCodecLTE != nil {
		predicates = append(predicates, episode.VideoCodecLTE(*i.VideoCodecLTE))
	}
	if i.VideoCodecContains != nil {
		predicates = append(predicates, episode.VideoCodecContains(*i.VideoCodecContains))
	}
	if i.VideoCodecHasPrefix != nil {
		predicates = append(predicates, episode.VideoCodecHasPrefix(*i.VideoCodecHasPrefix))
	}
	if i.VideoCodecHasSuffix != nil {
		predicates = append(predicates, episode.VideoCodecHasSuffix(*i.VideoCodecHasSuffix))
	}
	if i.VideoCodecIsNil {
		predicates = append(predicates, episode.VideoCodecIsNil())
	}
	if i.VideoCodecNotNil {
		predicates = append(predicates, episode.VideoCodecNotNil())
	}
	if i.VideoCodecEqualFold != nil {
		predicates = append(predicates, episode.VideoCodecEqualFold(*i.VideoCodecEqualFold))
	}
	if i.VideoCodecContainsFold != nil {
		predicates = append(predicates, episode.VideoCodecContainsFold(*i.VideoCodecContainsFold))
	}
	if i.AudioCodec != nil {
		predicates = append(predicates, episode.AudioCodecEQ(*i.AudioCodec))
	}
	if i.AudioCodecNEQ != nil {
		predicates = append(predicates, episode.AudioCodecNEQ(*i.AudioCodecNEQ))
	}
	if len(i.AudioCodecIn) > 0 {
		predicates = append(predicates, episode.AudioCodecIn(i.AudioCodecIn...))
	}
	if len(i.AudioCodecNotIn) > 0 {
		predicates = append(predicates, episode.AudioCodecNotIn(i.AudioCodecNotIn...))
	}
	if i.AudioCodecGT != nil {
		predicates = append(predicates, episode.AudioCodecGT(*i.AudioCodecGT))
	}
	if i.AudioCodecGTE != nil {
		predicates = append(predicates, episode.AudioCodecGTE(*i.AudioCodecGTE))
	}
	if i.AudioCodecLT != nil {
		predicates = append(predicates, episode.AudioCodecLT(*i.AudioCodecLT))
	}
	if i.AudioCodecLTE != nil {
		predicates = append(predicates, episode.AudioCodecLTE(*i.AudioCodecLTE))
	}
	if i.AudioCodecContains != nil {
		predicates = append(predicates, episode.AudioCodecContains(*i.AudioCodecContains))
	}
	if i.AudioCodecHasPrefix != nil {
		predicates = append(predicates, episode.AudioCodecHasPrefix(*i.AudioCodecHasPrefix))
	}
	if i.AudioCodecHasSuffix != nil {
		predicates = append(predicates, episode.AudioCodecHasSuffix(*i.AudioCodecHasSuffix))
	}
	if i.AudioCodecIsNil {
		predicates = append(predicates, episode.AudioCodecIsNil())
	}
	if i.AudioCodecNotNil {
		predicates = append(predicates, episode.AudioCodecNotNil())
	}
	if i.AudioCodecEqualFold != nil {
		predicates = append(predicates, episode.AudioCodecEqualFold(*i.AudioCodecEqualFold))
	}
	if i.AudioCodecContainsFold != nil {
		predicates = append(predicates, episode.AudioCodecContainsFold(*i.AudioCodecContainsFold))
	}

	if i.HasItem != nil {
		p := episode.HasItem()
		if !*i.HasItem {
			p = episode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasItemWith))
		for _, w := range i.HasItemWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, episode.HasItemWith(with...))
	}
	if i.HasAnime != nil {
		p := episode.HasAnime()
		if !*i.HasAnime {
			p = episode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAnimeWith) > 0 {
		with := make([]predicate.Anime, 0, len(i.HasAnimeWith))
		for _, w := range i.HasAnimeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAnimeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, episode.HasAnimeWith(with...))
	}
	if i.HasReleaseGroup != nil {
		p := episode.HasReleaseGroup()
		if !*i.HasReleaseGroup {
			p = episode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseGroupWith) > 0 {
		with := make([]predicate.ReleaseGroup, 0, len(i.HasReleaseGroupWith))
		for _, w := range i.HasReleaseGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReleaseGroupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, episode.HasReleaseGroupWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEpisodeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return episode.And(predicates...), nil
	}
}

// ItemWhereInput represents a where input for filtering Item queries.
type ItemWhereInput struct {
	Predicates []predicate.Item  `json:"-"`
	Not        *ItemWhereInput   `json:"not,omitempty"`
	Or         []*ItemWhereInput `json:"or,omitempty"`
	And        []*ItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "view_url" field predicates.
	ViewURL             *string  `json:"viewURL,omitempty"`
	ViewURLNEQ          *string  `json:"viewURLNEQ,omitempty"`
	ViewURLIn           []string `json:"viewURLIn,omitempty"`
	ViewURLNotIn        []string `json:"viewURLNotIn,omitempty"`
	ViewURLGT           *string  `json:"viewURLGT,omitempty"`
	ViewURLGTE          *string  `json:"viewURLGTE,omitempty"`
	ViewURLLT           *string  `json:"viewURLLT,omitempty"`
	ViewURLLTE          *string  `json:"viewURLLTE,omitempty"`
	ViewURLContains     *string  `json:"viewURLContains,omitempty"`
	ViewURLHasPrefix    *string  `json:"viewURLHasPrefix,omitempty"`
	ViewURLHasSuffix    *string  `json:"viewURLHasSuffix,omitempty"`
	ViewURLEqualFold    *string  `json:"viewURLEqualFold,omitempty"`
	ViewURLContainsFold *string  `json:"viewURLContainsFold,omitempty"`

	// "download_url" field predicates.
	DownloadURL             *string  `json:"downloadURL,omitempty"`
	DownloadURLNEQ          *string  `json:"downloadURLNEQ,omitempty"`
	DownloadURLIn           []string `json:"downloadURLIn,omitempty"`
	DownloadURLNotIn        []string `json:"downloadURLNotIn,omitempty"`
	DownloadURLGT           *string  `json:"downloadURLGT,omitempty"`
	DownloadURLGTE          *string  `json:"downloadURLGTE,omitempty"`
	DownloadURLLT           *string  `json:"downloadURLLT,omitempty"`
	DownloadURLLTE          *string  `json:"downloadURLLTE,omitempty"`
	DownloadURLContains     *string  `json:"downloadURLContains,omitempty"`
	DownloadURLHasPrefix    *string  `json:"downloadURLHasPrefix,omitempty"`
	DownloadURLHasSuffix    *string  `json:"downloadURLHasSuffix,omitempty"`
	DownloadURLEqualFold    *string  `json:"downloadURLEqualFold,omitempty"`
	DownloadURLContainsFold *string  `json:"downloadURLContainsFold,omitempty"`

	// "file_name" field predicates.
	FileName             *string  `json:"fileName,omitempty"`
	FileNameNEQ          *string  `json:"fileNameNEQ,omitempty"`
	FileNameIn           []string `json:"fileNameIn,omitempty"`
	FileNameNotIn        []string `json:"fileNameNotIn,omitempty"`
	FileNameGT           *string  `json:"fileNameGT,omitempty"`
	FileNameGTE          *string  `json:"fileNameGTE,omitempty"`
	FileNameLT           *string  `json:"fileNameLT,omitempty"`
	FileNameLTE          *string  `json:"fileNameLTE,omitempty"`
	FileNameContains     *string  `json:"fileNameContains,omitempty"`
	FileNameHasPrefix    *string  `json:"fileNameHasPrefix,omitempty"`
	FileNameHasSuffix    *string  `json:"fileNameHasSuffix,omitempty"`
	FileNameEqualFold    *string  `json:"fileNameEqualFold,omitempty"`
	FileNameContainsFold *string  `json:"fileNameContainsFold,omitempty"`

	// "file_size" field predicates.
	FileSize      *int  `json:"fileSize,omitempty"`
	FileSizeNEQ   *int  `json:"fileSizeNEQ,omitempty"`
	FileSizeIn    []int `json:"fileSizeIn,omitempty"`
	FileSizeNotIn []int `json:"fileSizeNotIn,omitempty"`
	FileSizeGT    *int  `json:"fileSizeGT,omitempty"`
	FileSizeGTE   *int  `json:"fileSizeGTE,omitempty"`
	FileSizeLT    *int  `json:"fileSizeLT,omitempty"`
	FileSizeLTE   *int  `json:"fileSizeLTE,omitempty"`

	// "publish_date" field predicates.
	PublishDate      *time.Time  `json:"publishDate,omitempty"`
	PublishDateNEQ   *time.Time  `json:"publishDateNEQ,omitempty"`
	PublishDateIn    []time.Time `json:"publishDateIn,omitempty"`
	PublishDateNotIn []time.Time `json:"publishDateNotIn,omitempty"`
	PublishDateGT    *time.Time  `json:"publishDateGT,omitempty"`
	PublishDateGTE   *time.Time  `json:"publishDateGTE,omitempty"`
	PublishDateLT    *time.Time  `json:"publishDateLT,omitempty"`
	PublishDateLTE   *time.Time  `json:"publishDateLTE,omitempty"`

	// "episode" edge predicates.
	HasEpisode     *bool                `json:"hasEpisode,omitempty"`
	HasEpisodeWith []*EpisodeWhereInput `json:"hasEpisodeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ItemWhereInput) AddPredicates(predicates ...predicate.Item) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ItemWhereInput filter on the ItemQuery builder.
func (i *ItemWhereInput) Filter(q *ItemQuery) (*ItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyItemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyItemWhereInput is returned in case the ItemWhereInput is empty.
var ErrEmptyItemWhereInput = errors.New("ent: empty predicate ItemWhereInput")

// P returns a predicate for filtering items.
// An error is returned if the input is empty or invalid.
func (i *ItemWhereInput) P() (predicate.Item, error) {
	var predicates []predicate.Item
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, item.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Item, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, item.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Item, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, item.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, item.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, item.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, item.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, item.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, item.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, item.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, item.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, item.IDLTE(*i.IDLTE))
	}
	if i.ViewURL != nil {
		predicates = append(predicates, item.ViewURLEQ(*i.ViewURL))
	}
	if i.ViewURLNEQ != nil {
		predicates = append(predicates, item.ViewURLNEQ(*i.ViewURLNEQ))
	}
	if len(i.ViewURLIn) > 0 {
		predicates = append(predicates, item.ViewURLIn(i.ViewURLIn...))
	}
	if len(i.ViewURLNotIn) > 0 {
		predicates = append(predicates, item.ViewURLNotIn(i.ViewURLNotIn...))
	}
	if i.ViewURLGT != nil {
		predicates = append(predicates, item.ViewURLGT(*i.ViewURLGT))
	}
	if i.ViewURLGTE != nil {
		predicates = append(predicates, item.ViewURLGTE(*i.ViewURLGTE))
	}
	if i.ViewURLLT != nil {
		predicates = append(predicates, item.ViewURLLT(*i.ViewURLLT))
	}
	if i.ViewURLLTE != nil {
		predicates = append(predicates, item.ViewURLLTE(*i.ViewURLLTE))
	}
	if i.ViewURLContains != nil {
		predicates = append(predicates, item.ViewURLContains(*i.ViewURLContains))
	}
	if i.ViewURLHasPrefix != nil {
		predicates = append(predicates, item.ViewURLHasPrefix(*i.ViewURLHasPrefix))
	}
	if i.ViewURLHasSuffix != nil {
		predicates = append(predicates, item.ViewURLHasSuffix(*i.ViewURLHasSuffix))
	}
	if i.ViewURLEqualFold != nil {
		predicates = append(predicates, item.ViewURLEqualFold(*i.ViewURLEqualFold))
	}
	if i.ViewURLContainsFold != nil {
		predicates = append(predicates, item.ViewURLContainsFold(*i.ViewURLContainsFold))
	}
	if i.DownloadURL != nil {
		predicates = append(predicates, item.DownloadURLEQ(*i.DownloadURL))
	}
	if i.DownloadURLNEQ != nil {
		predicates = append(predicates, item.DownloadURLNEQ(*i.DownloadURLNEQ))
	}
	if len(i.DownloadURLIn) > 0 {
		predicates = append(predicates, item.DownloadURLIn(i.DownloadURLIn...))
	}
	if len(i.DownloadURLNotIn) > 0 {
		predicates = append(predicates, item.DownloadURLNotIn(i.DownloadURLNotIn...))
	}
	if i.DownloadURLGT != nil {
		predicates = append(predicates, item.DownloadURLGT(*i.DownloadURLGT))
	}
	if i.DownloadURLGTE != nil {
		predicates = append(predicates, item.DownloadURLGTE(*i.DownloadURLGTE))
	}
	if i.DownloadURLLT != nil {
		predicates = append(predicates, item.DownloadURLLT(*i.DownloadURLLT))
	}
	if i.DownloadURLLTE != nil {
		predicates = append(predicates, item.DownloadURLLTE(*i.DownloadURLLTE))
	}
	if i.DownloadURLContains != nil {
		predicates = append(predicates, item.DownloadURLContains(*i.DownloadURLContains))
	}
	if i.DownloadURLHasPrefix != nil {
		predicates = append(predicates, item.DownloadURLHasPrefix(*i.DownloadURLHasPrefix))
	}
	if i.DownloadURLHasSuffix != nil {
		predicates = append(predicates, item.DownloadURLHasSuffix(*i.DownloadURLHasSuffix))
	}
	if i.DownloadURLEqualFold != nil {
		predicates = append(predicates, item.DownloadURLEqualFold(*i.DownloadURLEqualFold))
	}
	if i.DownloadURLContainsFold != nil {
		predicates = append(predicates, item.DownloadURLContainsFold(*i.DownloadURLContainsFold))
	}
	if i.FileName != nil {
		predicates = append(predicates, item.FileNameEQ(*i.FileName))
	}
	if i.FileNameNEQ != nil {
		predicates = append(predicates, item.FileNameNEQ(*i.FileNameNEQ))
	}
	if len(i.FileNameIn) > 0 {
		predicates = append(predicates, item.FileNameIn(i.FileNameIn...))
	}
	if len(i.FileNameNotIn) > 0 {
		predicates = append(predicates, item.FileNameNotIn(i.FileNameNotIn...))
	}
	if i.FileNameGT != nil {
		predicates = append(predicates, item.FileNameGT(*i.FileNameGT))
	}
	if i.FileNameGTE != nil {
		predicates = append(predicates, item.FileNameGTE(*i.FileNameGTE))
	}
	if i.FileNameLT != nil {
		predicates = append(predicates, item.FileNameLT(*i.FileNameLT))
	}
	if i.FileNameLTE != nil {
		predicates = append(predicates, item.FileNameLTE(*i.FileNameLTE))
	}
	if i.FileNameContains != nil {
		predicates = append(predicates, item.FileNameContains(*i.FileNameContains))
	}
	if i.FileNameHasPrefix != nil {
		predicates = append(predicates, item.FileNameHasPrefix(*i.FileNameHasPrefix))
	}
	if i.FileNameHasSuffix != nil {
		predicates = append(predicates, item.FileNameHasSuffix(*i.FileNameHasSuffix))
	}
	if i.FileNameEqualFold != nil {
		predicates = append(predicates, item.FileNameEqualFold(*i.FileNameEqualFold))
	}
	if i.FileNameContainsFold != nil {
		predicates = append(predicates, item.FileNameContainsFold(*i.FileNameContainsFold))
	}
	if i.FileSize != nil {
		predicates = append(predicates, item.FileSizeEQ(*i.FileSize))
	}
	if i.FileSizeNEQ != nil {
		predicates = append(predicates, item.FileSizeNEQ(*i.FileSizeNEQ))
	}
	if len(i.FileSizeIn) > 0 {
		predicates = append(predicates, item.FileSizeIn(i.FileSizeIn...))
	}
	if len(i.FileSizeNotIn) > 0 {
		predicates = append(predicates, item.FileSizeNotIn(i.FileSizeNotIn...))
	}
	if i.FileSizeGT != nil {
		predicates = append(predicates, item.FileSizeGT(*i.FileSizeGT))
	}
	if i.FileSizeGTE != nil {
		predicates = append(predicates, item.FileSizeGTE(*i.FileSizeGTE))
	}
	if i.FileSizeLT != nil {
		predicates = append(predicates, item.FileSizeLT(*i.FileSizeLT))
	}
	if i.FileSizeLTE != nil {
		predicates = append(predicates, item.FileSizeLTE(*i.FileSizeLTE))
	}
	if i.PublishDate != nil {
		predicates = append(predicates, item.PublishDateEQ(*i.PublishDate))
	}
	if i.PublishDateNEQ != nil {
		predicates = append(predicates, item.PublishDateNEQ(*i.PublishDateNEQ))
	}
	if len(i.PublishDateIn) > 0 {
		predicates = append(predicates, item.PublishDateIn(i.PublishDateIn...))
	}
	if len(i.PublishDateNotIn) > 0 {
		predicates = append(predicates, item.PublishDateNotIn(i.PublishDateNotIn...))
	}
	if i.PublishDateGT != nil {
		predicates = append(predicates, item.PublishDateGT(*i.PublishDateGT))
	}
	if i.PublishDateGTE != nil {
		predicates = append(predicates, item.PublishDateGTE(*i.PublishDateGTE))
	}
	if i.PublishDateLT != nil {
		predicates = append(predicates, item.PublishDateLT(*i.PublishDateLT))
	}
	if i.PublishDateLTE != nil {
		predicates = append(predicates, item.PublishDateLTE(*i.PublishDateLTE))
	}

	if i.HasEpisode != nil {
		p := item.HasEpisode()
		if !*i.HasEpisode {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpisodeWith) > 0 {
		with := make([]predicate.Episode, 0, len(i.HasEpisodeWith))
		for _, w := range i.HasEpisodeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpisodeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasEpisodeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyItemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return item.And(predicates...), nil
	}
}

// ReleaseGroupWhereInput represents a where input for filtering ReleaseGroup queries.
type ReleaseGroupWhereInput struct {
	Predicates []predicate.ReleaseGroup  `json:"-"`
	Not        *ReleaseGroupWhereInput   `json:"not,omitempty"`
	Or         []*ReleaseGroupWhereInput `json:"or,omitempty"`
	And        []*ReleaseGroupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "episodes" edge predicates.
	HasEpisodes     *bool                `json:"hasEpisodes,omitempty"`
	HasEpisodesWith []*EpisodeWhereInput `json:"hasEpisodesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReleaseGroupWhereInput) AddPredicates(predicates ...predicate.ReleaseGroup) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReleaseGroupWhereInput filter on the ReleaseGroupQuery builder.
func (i *ReleaseGroupWhereInput) Filter(q *ReleaseGroupQuery) (*ReleaseGroupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReleaseGroupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReleaseGroupWhereInput is returned in case the ReleaseGroupWhereInput is empty.
var ErrEmptyReleaseGroupWhereInput = errors.New("ent: empty predicate ReleaseGroupWhereInput")

// P returns a predicate for filtering releasegroups.
// An error is returned if the input is empty or invalid.
func (i *ReleaseGroupWhereInput) P() (predicate.ReleaseGroup, error) {
	var predicates []predicate.ReleaseGroup
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, releasegroup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReleaseGroup, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, releasegroup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReleaseGroup, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, releasegroup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, releasegroup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, releasegroup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, releasegroup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, releasegroup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, releasegroup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, releasegroup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, releasegroup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, releasegroup.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, releasegroup.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, releasegroup.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, releasegroup.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, releasegroup.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, releasegroup.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, releasegroup.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, releasegroup.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, releasegroup.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, releasegroup.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, releasegroup.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, releasegroup.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, releasegroup.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, releasegroup.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasEpisodes != nil {
		p := releasegroup.HasEpisodes()
		if !*i.HasEpisodes {
			p = releasegroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpisodesWith) > 0 {
		with := make([]predicate.Episode, 0, len(i.HasEpisodesWith))
		for _, w := range i.HasEpisodesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpisodesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasegroup.HasEpisodesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReleaseGroupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return releasegroup.And(predicates...), nil
	}
}
