// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/eiri/konyanko/ent"
	"github.com/eiri/konyanko/ent/anime"
	"github.com/eiri/konyanko/ent/episode"
	"github.com/eiri/konyanko/ent/item"
	"github.com/eiri/konyanko/ent/releasegroup"
	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateAnime handles POST /animes requests.
func (h *OgentHandler) CreateAnime(ctx context.Context, req *CreateAnimeReq) (CreateAnimeRes, error) {
	b := h.client.Anime.Create()
	// Add all fields.
	b.SetTitle(req.Title)
	// Add all edges.
	b.AddEpisodeIDs(req.Episodes...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Anime.Query().Where(anime.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewAnimeCreate(e), nil
}

// ReadAnime handles GET /animes/{id} requests.
func (h *OgentHandler) ReadAnime(ctx context.Context, params ReadAnimeParams) (ReadAnimeRes, error) {
	q := h.client.Anime.Query().Where(anime.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewAnimeRead(e), nil
}

// UpdateAnime handles PATCH /animes/{id} requests.
func (h *OgentHandler) UpdateAnime(ctx context.Context, req *UpdateAnimeReq, params UpdateAnimeParams) (UpdateAnimeRes, error) {
	b := h.client.Anime.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Title.Get(); ok {
		b.SetTitle(v)
	}
	// Add all edges.
	if req.Episodes != nil {
		b.ClearEpisodes().AddEpisodeIDs(req.Episodes...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Anime.Query().Where(anime.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewAnimeUpdate(e), nil
}

// DeleteAnime handles DELETE /animes/{id} requests.
func (h *OgentHandler) DeleteAnime(ctx context.Context, params DeleteAnimeParams) (DeleteAnimeRes, error) {
	err := h.client.Anime.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteAnimeNoContent), nil

}

// ListAnime handles GET /animes requests.
func (h *OgentHandler) ListAnime(ctx context.Context, params ListAnimeParams) (ListAnimeRes, error) {
	q := h.client.Anime.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewAnimeLists(es)
	return (*ListAnimeOKApplicationJSON)(&r), nil
}

// ListAnimeEpisodes handles GET /animes/{id}/episodes requests.
func (h *OgentHandler) ListAnimeEpisodes(ctx context.Context, params ListAnimeEpisodesParams) (ListAnimeEpisodesRes, error) {
	q := h.client.Anime.Query().Where(anime.IDEQ(params.ID)).QueryEpisodes()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewAnimeEpisodesLists(es)
	return (*ListAnimeEpisodesOKApplicationJSON)(&r), nil
}

// CreateEpisode handles POST /episodes requests.
func (h *OgentHandler) CreateEpisode(ctx context.Context, req *CreateEpisodeReq) (CreateEpisodeRes, error) {
	b := h.client.Episode.Create()
	// Add all fields.
	b.SetEpisodeNumber(req.EpisodeNumber)
	b.SetAnimeSeason(req.AnimeSeason)
	if v, ok := req.Resolution.Get(); ok {
		b.SetResolution(v)
	}
	if v, ok := req.VideoCodec.Get(); ok {
		b.SetVideoCodec(v)
	}
	if v, ok := req.AudioCodec.Get(); ok {
		b.SetAudioCodec(v)
	}
	// Add all edges.
	b.SetItemID(req.Item)
	b.SetTitleID(req.Title)
	if v, ok := req.ReleaseGroup.Get(); ok {
		b.SetReleaseGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Episode.Query().Where(episode.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEpisodeCreate(e), nil
}

// ReadEpisode handles GET /episodes/{id} requests.
func (h *OgentHandler) ReadEpisode(ctx context.Context, params ReadEpisodeParams) (ReadEpisodeRes, error) {
	q := h.client.Episode.Query().Where(episode.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEpisodeRead(e), nil
}

// UpdateEpisode handles PATCH /episodes/{id} requests.
func (h *OgentHandler) UpdateEpisode(ctx context.Context, req *UpdateEpisodeReq, params UpdateEpisodeParams) (UpdateEpisodeRes, error) {
	b := h.client.Episode.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.EpisodeNumber.Get(); ok {
		b.SetEpisodeNumber(v)
	}
	if v, ok := req.AnimeSeason.Get(); ok {
		b.SetAnimeSeason(v)
	}
	if v, ok := req.Resolution.Get(); ok {
		b.SetResolution(v)
	}
	if v, ok := req.VideoCodec.Get(); ok {
		b.SetVideoCodec(v)
	}
	if v, ok := req.AudioCodec.Get(); ok {
		b.SetAudioCodec(v)
	}
	// Add all edges.
	if v, ok := req.Item.Get(); ok {
		b.SetItemID(v)
	}
	if v, ok := req.Title.Get(); ok {
		b.SetTitleID(v)
	}
	if v, ok := req.ReleaseGroup.Get(); ok {
		b.SetReleaseGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Episode.Query().Where(episode.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEpisodeUpdate(e), nil
}

// DeleteEpisode handles DELETE /episodes/{id} requests.
func (h *OgentHandler) DeleteEpisode(ctx context.Context, params DeleteEpisodeParams) (DeleteEpisodeRes, error) {
	err := h.client.Episode.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteEpisodeNoContent), nil

}

// ListEpisode handles GET /episodes requests.
func (h *OgentHandler) ListEpisode(ctx context.Context, params ListEpisodeParams) (ListEpisodeRes, error) {
	q := h.client.Episode.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEpisodeLists(es)
	return (*ListEpisodeOKApplicationJSON)(&r), nil
}

// ReadEpisodeItem handles GET /episodes/{id}/item requests.
func (h *OgentHandler) ReadEpisodeItem(ctx context.Context, params ReadEpisodeItemParams) (ReadEpisodeItemRes, error) {
	q := h.client.Episode.Query().Where(episode.IDEQ(params.ID)).QueryItem()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEpisodeItemRead(e), nil
}

// ReadEpisodeTitle handles GET /episodes/{id}/title requests.
func (h *OgentHandler) ReadEpisodeTitle(ctx context.Context, params ReadEpisodeTitleParams) (ReadEpisodeTitleRes, error) {
	q := h.client.Episode.Query().Where(episode.IDEQ(params.ID)).QueryTitle()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEpisodeTitleRead(e), nil
}

// ReadEpisodeReleaseGroup handles GET /episodes/{id}/release-group requests.
func (h *OgentHandler) ReadEpisodeReleaseGroup(ctx context.Context, params ReadEpisodeReleaseGroupParams) (ReadEpisodeReleaseGroupRes, error) {
	q := h.client.Episode.Query().Where(episode.IDEQ(params.ID)).QueryReleaseGroup()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEpisodeReleaseGroupRead(e), nil
}

// CreateItem handles POST /items requests.
func (h *OgentHandler) CreateItem(ctx context.Context, req *CreateItemReq) (CreateItemRes, error) {
	b := h.client.Item.Create()
	// Add all fields.
	b.SetViewURL(req.ViewURL)
	b.SetDownloadURL(req.DownloadURL)
	b.SetFileName(req.FileName)
	b.SetFileSize(req.FileSize)
	b.SetPublishDate(req.PublishDate)
	// Add all edges.
	if v, ok := req.Episodes.Get(); ok {
		b.SetEpisodesID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Item.Query().Where(item.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewItemCreate(e), nil
}

// ReadItem handles GET /items/{id} requests.
func (h *OgentHandler) ReadItem(ctx context.Context, params ReadItemParams) (ReadItemRes, error) {
	q := h.client.Item.Query().Where(item.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewItemRead(e), nil
}

// UpdateItem handles PATCH /items/{id} requests.
func (h *OgentHandler) UpdateItem(ctx context.Context, req *UpdateItemReq, params UpdateItemParams) (UpdateItemRes, error) {
	b := h.client.Item.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.ViewURL.Get(); ok {
		b.SetViewURL(v)
	}
	if v, ok := req.DownloadURL.Get(); ok {
		b.SetDownloadURL(v)
	}
	if v, ok := req.FileName.Get(); ok {
		b.SetFileName(v)
	}
	if v, ok := req.FileSize.Get(); ok {
		b.SetFileSize(v)
	}
	if v, ok := req.PublishDate.Get(); ok {
		b.SetPublishDate(v)
	}
	// Add all edges.
	if v, ok := req.Episodes.Get(); ok {
		b.SetEpisodesID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Item.Query().Where(item.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewItemUpdate(e), nil
}

// DeleteItem handles DELETE /items/{id} requests.
func (h *OgentHandler) DeleteItem(ctx context.Context, params DeleteItemParams) (DeleteItemRes, error) {
	err := h.client.Item.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteItemNoContent), nil

}

// ListItem handles GET /items requests.
func (h *OgentHandler) ListItem(ctx context.Context, params ListItemParams) (ListItemRes, error) {
	q := h.client.Item.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewItemLists(es)
	return (*ListItemOKApplicationJSON)(&r), nil
}

// ReadItemEpisodes handles GET /items/{id}/episodes requests.
func (h *OgentHandler) ReadItemEpisodes(ctx context.Context, params ReadItemEpisodesParams) (ReadItemEpisodesRes, error) {
	q := h.client.Item.Query().Where(item.IDEQ(params.ID)).QueryEpisodes()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewItemEpisodesRead(e), nil
}

// CreateReleaseGroup handles POST /release-groups requests.
func (h *OgentHandler) CreateReleaseGroup(ctx context.Context, req *CreateReleaseGroupReq) (CreateReleaseGroupRes, error) {
	b := h.client.ReleaseGroup.Create()
	// Add all fields.
	b.SetName(req.Name)
	// Add all edges.
	b.AddEpisodeIDs(req.Episodes...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ReleaseGroup.Query().Where(releasegroup.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewReleaseGroupCreate(e), nil
}

// ReadReleaseGroup handles GET /release-groups/{id} requests.
func (h *OgentHandler) ReadReleaseGroup(ctx context.Context, params ReadReleaseGroupParams) (ReadReleaseGroupRes, error) {
	q := h.client.ReleaseGroup.Query().Where(releasegroup.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewReleaseGroupRead(e), nil
}

// UpdateReleaseGroup handles PATCH /release-groups/{id} requests.
func (h *OgentHandler) UpdateReleaseGroup(ctx context.Context, req *UpdateReleaseGroupReq, params UpdateReleaseGroupParams) (UpdateReleaseGroupRes, error) {
	b := h.client.ReleaseGroup.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	if req.Episodes != nil {
		b.ClearEpisodes().AddEpisodeIDs(req.Episodes...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ReleaseGroup.Query().Where(releasegroup.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewReleaseGroupUpdate(e), nil
}

// DeleteReleaseGroup handles DELETE /release-groups/{id} requests.
func (h *OgentHandler) DeleteReleaseGroup(ctx context.Context, params DeleteReleaseGroupParams) (DeleteReleaseGroupRes, error) {
	err := h.client.ReleaseGroup.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteReleaseGroupNoContent), nil

}

// ListReleaseGroup handles GET /release-groups requests.
func (h *OgentHandler) ListReleaseGroup(ctx context.Context, params ListReleaseGroupParams) (ListReleaseGroupRes, error) {
	q := h.client.ReleaseGroup.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewReleaseGroupLists(es)
	return (*ListReleaseGroupOKApplicationJSON)(&r), nil
}

// ListReleaseGroupEpisodes handles GET /release-groups/{id}/episodes requests.
func (h *OgentHandler) ListReleaseGroupEpisodes(ctx context.Context, params ListReleaseGroupEpisodesParams) (ListReleaseGroupEpisodesRes, error) {
	q := h.client.ReleaseGroup.Query().Where(releasegroup.IDEQ(params.ID)).QueryEpisodes()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewReleaseGroupEpisodesLists(es)
	return (*ListReleaseGroupEpisodesOKApplicationJSON)(&r), nil
}
